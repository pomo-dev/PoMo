<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>libPoMo.cf &mdash; PoMo 1.0.2 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="PoMo 1.0.2 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">PoMo 1.0.2 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for libPoMo.cf</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;libPomo.cf</span>
<span class="sd">=============</span>

<span class="sd">This model provides functions to read, write and access files that are</span>
<span class="sd">in counts format.</span>

<span class="sd">The Counts Format</span>
<span class="sd">-----------------</span>
<span class="sd">This file format is used by PoMo and lists the base</span>
<span class="sd">counts for every position.</span>

<span class="sd">It contains:</span>
<span class="sd">  - 1 headerline with tab separated sequence names</span>
<span class="sd">  - N lines with counts of A, C, G and T bases at position n</span>

<span class="sd">::</span>

<span class="sd">  CHROM \t Pos   \t Sheep   \t BlackSheep \t RedSheep \t Wolf    \t RedWolf</span>
<span class="sd">  chrA  \t s     \t 0,0,1,0 \t 0,0,1,0    \t 0,0,1,0  \t 0,0,5,0 \t 0,0,0,1</span>
<span class="sd">  chrA  \t s + 1 \t 0,0,0,1 \t 0,0,0,1    \t 0,0,0,1  \t 0,0,0,5 \t 0,0,0,1</span>
<span class="sd">  .</span>
<span class="sd">  .</span>
<span class="sd">  .</span>
<span class="sd">  chrF  \t 8373  \t 0,0,0,1 \t 1,0,0,0    \t 0,1,0,0  \t 0,1,4,0 \t 0,0,1,0</span>
<span class="sd">  .</span>
<span class="sd">  .</span>
<span class="sd">  .</span>
<span class="sd">  chrE  \t end   \t 0,0,0,1 \t 0,1,0,0    \t 0,1,0,0  \t 0,5,0,0 \t 0,0,1,0</span>

<span class="sd">Convert to Counts Format</span>
<span class="sd">------------------------</span>

<span class="sd">To convert a fasta reference file with SNP information from a variant</span>
<span class="sd">call format (VCF) to counts format use the :class:`CFWriter`. If you</span>
<span class="sd">want to convert a multiple alignment fasta file, use the</span>
<span class="sd">:class:`CFWriter` together with the convenience function</span>
<span class="sd">:func:`write_cf_from_MFaStream()`.</span>

<span class="sd">Tabix index files need to be provided for all VCF files. They can be</span>
<span class="sd">created from the terminal with $(tabix -p vcf &quot;vcf-file.vcf.gz&quot;) if</span>
<span class="sd">tabix is installed.</span>

<span class="sd">A code example is::</span>

<span class="sd">  import import_libPoMo</span>
<span class="sd">  import libPoMo.fasta as fa</span>
<span class="sd">  import libPoMo.cf as cf</span>

<span class="sd">  vcfFL = [&quot;/path/to/vcf/file1&quot;, &quot;/path/to/vcf/file2&quot;, &quot;...&quot;]</span>

<span class="sd">  cfw = cf.CFWriter(vcfFL, &quot;name-of-outfile&quot;)</span>
<span class="sd">  mFaStr = fa.MFaStream(&quot;/path/to/fasta/reference&quot;)</span>

<span class="sd">  cfw.write_HLn()</span>
<span class="sd">  cf.write_cf_from_MFaStream(mFaStr, cfw)</span>

<span class="sd">  cfw.close()</span>

<span class="sd">Objects</span>
<span class="sd">-------</span>
<span class="sd">Classes:</span>
<span class="sd">  - :class:`CFWriter`, write a counts format file</span>

<span class="sd">Exception Classes:</span>
<span class="sd">  - :class:`CountsFormatWriterError`</span>

<span class="sd">Functions:</span>
<span class="sd">  - :func:`write_cf_from_MFaStream()`, write counts file using the</span>
<span class="sd">    given MFaStream and CFWriter</span>

<span class="sd">----</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s">&#39;restructuredtext&#39;</span>

<span class="kn">import</span> <span class="nn">pysam</span> <span class="kn">as</span> <span class="nn">ps</span>

<span class="kn">import</span> <span class="nn">libPoMo.seqbase</span> <span class="kn">as</span> <span class="nn">sb</span>
<span class="kn">import</span> <span class="nn">libPoMo.vcf</span> <span class="kn">as</span> <span class="nn">vcf</span>

<span class="n">dna</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;t&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>


<div class="viewcode-block" id="CountsFormatWriterError"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CountsFormatWriterError">[docs]</a><span class="k">class</span> <span class="nc">CountsFormatWriterError</span><span class="p">(</span><span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;General `CFWriter` object error.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

</div>
<div class="viewcode-block" id="NoSynBase"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.NoSynBase">[docs]</a><span class="k">class</span> <span class="nc">NoSynBase</span><span class="p">(</span><span class="n">sb</span><span class="o">.</span><span class="n">NotAValidRefBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Not a 4-fold degenerate site.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

</div>
<div class="viewcode-block" id="CFWriter"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter">[docs]</a><span class="k">class</span> <span class="nc">CFWriter</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Write a counts format file.</span>

<span class="sd">    Save information that is needed to write a CF file and use this</span>
<span class="sd">    information to write a CF file.  Initialize with a list of vcf</span>
<span class="sd">    file names and an output file name::</span>

<span class="sd">      CFWriter([vcfFileNames], &quot;output&quot;)</span>

<span class="sd">    Tabix index files need to be provided for all VCF files. They can</span>
<span class="sd">    be created from the terminal with $(tabix -p vcf</span>
<span class="sd">    &quot;vcf-file.vcf.gz&quot;) if tabix is installed.</span>

<span class="sd">    Before the count file can be written, a reference sequence has to</span>
<span class="sd">    be specified.  A single reference sequence can be set with</span>
<span class="sd">    :func:`set_seq`.</span>

<span class="sd">    Write a header line to output::</span>

<span class="sd">       self.write_HLn()</span>

<span class="sd">    Write lines in counts format from 1-based positions *start* to</span>
<span class="sd">    *end* on chromosome *chrom* to output::</span>

<span class="sd">       rg = sb.Region(&quot;chrom&quot;, start, end)</span>
<span class="sd">       self.write_Rn(rg)</span>

<span class="sd">    If you want to compare the SNPs of the VCF files to a multiple</span>
<span class="sd">    alingment fasta stream (:class:`MFaStream</span>
<span class="sd">    &lt;libPoMo.fasta.MFaStream&gt;`) consider the very convenient function</span>
<span class="sd">    :func:`write_cf_from_MFaStream`.</span>

<span class="sd">    To determine the different populations present in the VCF files,</span>
<span class="sd">    the names of the individuals will be cropped at a specific char</span>
<span class="sd">    that can be set at initialization (standard value = &#39;-&#39;). It is</span>
<span class="sd">    also possible to collapse all individuals of determined VCF files</span>
<span class="sd">    to a single population (cf. mergeL and nameL).</span>

<span class="sd">    The ploidity has to be set manually if it differs from 2.</span>

<span class="sd">    Additional filters can be set before the counts file is written</span>
<span class="sd">    (e.g. only write synonymous sites).</span>

<span class="sd">    Remember to close the attached file objectsL with :func:`close`.</span>

<span class="sd">    :param [str] vcfFileNameL: List with names of vcf files.</span>
<span class="sd">    :param str outFileName: Output file name.</span>
<span class="sd">    :param int verb: Optional; verbosity level.</span>
<span class="sd">    :param char splitChar: Optional; set the split character so that</span>
<span class="sd">      the individuals get sorted into the correct populations.</span>
<span class="sd">    :param [Boolean] mergeL: Optional; a list of truth values.  If</span>
<span class="sd">      *mL[i]* is True, all individuals of *self.vcfL[i]* are treated as</span>
<span class="sd">      one population orspecies independent of their name.  The</span>
<span class="sd">      respective counts are summed up.  If *self.nL[i]* is given, the</span>
<span class="sd">      name of the summed sequence will be *self.nL[i]*.  If not, the</span>
<span class="sd">      name of the first individual in *vcfL[i]* will be used.</span>
<span class="sd">    :param [str] nameL: Optional; a list of names. Cf. *self.mL*.</span>

<span class="sd">    :ivar str refFN: Name of reference fasta file.</span>
<span class="sd">    :ivar [str] vcfL: List with names of vcf files.</span>
<span class="sd">    :ivar str outFN: Output file name.</span>
<span class="sd">    :ivar int v: Verbosity.</span>
<span class="sd">    :ivar [Boolean] mL: A list of truth values.  If *mL[i]* is True,</span>
<span class="sd">        all individuals of *self.vcfL[i]* are treated as one</span>
<span class="sd">        population orspecies independent of their name.  The</span>
<span class="sd">        respective counts are summed up.  If *self.nL[i]* is given,</span>
<span class="sd">        the name of the summed sequence will be *self.nL[i]*.  If not,</span>
<span class="sd">        the name of the first individual in *vcfL[i]* will be used.</span>
<span class="sd">    :ivar [str] nL: A list of names. Cf. *self.mL*.</span>
<span class="sd">    :ivar int nV: Number of vcf files.</span>
<span class="sd">    :ivar [fo] vcfTfL: List with *pysam.Tabixfile* objects. Filled by</span>
<span class="sd">        *self.__init_vcfTfL()* during initialization.</span>
<span class="sd">    :ivar fo outFO: File object of the outfile. Filled by</span>
<span class="sd">        *self.__init_outFO()* during initialization.</span>
<span class="sd">    :ivar cD: List with allele or base counts. The alleles of</span>
<span class="sd">        individuals from the same population are summed up.  Hence,</span>
<span class="sd">        *self.cD[p]* gives the base counts of population *p* in the</span>
<span class="sd">        form: [0, 0, 0, 0].  Population *p`*does not need to be the</span>
<span class="sd">        one from *self.vcfL[p]* because several populations might be</span>
<span class="sd">        present in one vcf file.  *self.assM* connects the individual</span>
<span class="sd">        j from *self.vcfL[i]* such that *self.assM[i][j]* is *p*.</span>
<span class="sd">    :ivar str chrom: Name of the current chromosome. Set and updated</span>
<span class="sd">        by :func:`write_Rn`.</span>
<span class="sd">    :ivar int pos: Current position on chromosome. Set and updated by</span>
<span class="sd">        :func:`write_Rn`.</span>
<span class="sd">    :ivar int offset: Value that can be set with :func:`set_offset`,</span>
<span class="sd">                      if the reference sequence does not start at the</span>
<span class="sd">                      1-based position 1 but at the 1-based position</span>
<span class="sd">                      *offset*.</span>
<span class="sd">    :ivar indM: Matrix with individuals from vcf files. *self.indM[i]*</span>
<span class="sd">        is the list of individuals found in *self.vcfL[i]*.</span>
<span class="sd">    :ivar [int] nIndL: List with number of individuals in</span>
<span class="sd">        *self.vcfL[i]*.</span>
<span class="sd">    :ivar assM: Assignment matrix that connects the individuals from</span>
<span class="sd">        the vcf files to the correct *self.cd* index.  Cf. *self.cD*</span>
<span class="sd">    :ivar int nPop: Number of different populations in count format</span>
<span class="sd">        output file (e.g. number of populations).  Filled by</span>
<span class="sd">        *self.__init_assM()* during initialization.</span>
<span class="sd">    :ivar Seq refSeq: :class:`Seq &lt;libPoMo.seqbase.Seq&gt;` object of the</span>
<span class="sd">        reference Sequence. This has to be set with :class:`set_seq`.</span>
<span class="sd">    :ivar int ploidy: Ploidy of individuals in vcf files.  This has to</span>
<span class="sd">        be set manually to the correct value for non-diploids!</span>
<span class="sd">    :ivar char splitCh: Character that is used to split the</span>
<span class="sd">        individual names.</span>
<span class="sd">    :ivar Boolean onlySynonymous: Only write 4-fold degenerate sites.</span>
<span class="sd">    :ivar Boolean __force: If set to true, skip name checks.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vcfFileNameL</span><span class="p">,</span> <span class="n">outFileName</span><span class="p">,</span> <span class="n">verb</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">splitChar</span><span class="o">=</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="n">mergeL</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">nameL</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># Passed variables.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcfL</span> <span class="o">=</span> <span class="n">vcfFileNameL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outFN</span> <span class="o">=</span> <span class="n">outFileName</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">verb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mL</span> <span class="o">=</span> <span class="n">mergeL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">=</span> <span class="n">nameL</span>
        <span class="c"># Variables that are filled during initialization.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nV</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcfL</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outFO</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cD</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indM</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nIndL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assM</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nPop</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># Variables that have to be set manually.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refSeq</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splitCh</span> <span class="o">=</span> <span class="n">splitChar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onlySynonymous</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__force</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__init_vcfTfL</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_outFO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_indM</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_nIndL</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_assM</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_nL</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_cD</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init_vcfTfL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open vcf files given in *self.vcfL*.</span>

<span class="sd">        Tabix index files need to be provided. They can be created</span>
<span class="sd">        from the terminal with $(tabix -p vcf &quot;vcf-file.vcf.gz&quot;). The</span>
<span class="sd">        tabix file objects are stored in *self.vcfTfL*. They need to</span>
<span class="sd">        be closed with :func:`close`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcfL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">Tabixfile</span><span class="p">(</span><span class="n">fn</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__init_outFO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open *self.outFN*.</span>

<span class="sd">        If the file name ends with &quot;gz&quot;, the outfile will be</span>
<span class="sd">        compressed and is opened with gzip.open().</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outFO</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">gz_open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outFN</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_indM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Extract individuals from the vcf files.&quot;&quot;&quot;</span>
        <span class="c"># Get individuals from the vcf files.</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">tf</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
                <span class="n">hLn</span> <span class="o">=</span> <span class="n">ln</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">vcf</span><span class="o">.</span><span class="n">get_indiv_from_field_header</span><span class="p">(</span><span class="n">hLn</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&quot;utf-8&quot;</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__init_nIndL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Count individuals in each vcf file.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">indL</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nIndL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indL</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__init_assM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill assignment matrix *self.assM*.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">collapse_and_append</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dN</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Collapse individual names of *self.vcfL[n]*.</span>

<span class="sd">            Appends the collapsed individual names of *self.vcfL[n]*</span>
<span class="sd">            to *self.assM*.</span>

<span class="sd">            :param int n: Index.</span>
<span class="sd">            :param int dN: Offset in assL.</span>
<span class="sd">            :rtype: int</span>

<span class="sd">            Returns new offset.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splitCh</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                 <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
            <span class="n">aL</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cL</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">ddN</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">cL</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="n">aL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">dN</span><span class="o">+</span><span class="n">index</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">ddN</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">cL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="n">aL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">dN</span><span class="o">+</span><span class="n">ddN</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aL</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dN</span> <span class="o">+</span> <span class="n">ddN</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dI</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="n">dI</span> <span class="o">=</span> <span class="n">collapse_and_append</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dI</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mL</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="n">dI</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nIndL</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">dI</span><span class="p">])</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="n">dI</span> <span class="o">=</span> <span class="n">collapse_and_append</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dI</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">CountsFormatWriterError</span><span class="p">(</span><span class="s">&quot;Merge list is not &quot;</span> <span class="o">+</span>
                                                  <span class="s">&quot;a list of boolean values.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CountsFormatWriterError</span><span class="p">(</span><span class="s">&quot;`mergeL` is not valid.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nPop</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dI</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__init_nL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill *self.nL*.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">append_to_nL</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">splitCh</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="n">append_to_nL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CountsFormatWriterError</span><span class="p">(</span><span class="s">&quot;`nameL` is not valid.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_cD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the list with counts data.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cD</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPop</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__snp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate SNPs in region *rg* out of *self.vcfL*.</span>

<span class="sd">        Generator that returns the next SNP in region *rg*</span>
<span class="sd">        (cf. :class:`Region &lt;libPoMo.seqbase.Region&gt;`) as a :class:`NucBase`</span>
<span class="sd">        object.  To loop over all SNPs in region *rg*:</span>

<span class="sd">        &gt;&gt;&gt; rg = sb.Region(&quot;chr1&quot;, 500000, 1000000)</span>
<span class="sd">        &gt;&gt;&gt; for s in self.snp(rg):</span>
<span class="sd">        ....:   s.print_info()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">snpL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">snpIterL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
            <span class="n">snpIterL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">reference</span><span class="o">=</span><span class="n">rg</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                                                 <span class="n">start</span><span class="o">=</span><span class="n">rg</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">rg</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">snpL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vcf</span><span class="o">.</span><span class="n">get_nuc_base_from_line</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">snpIterL</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                                       <span class="n">ploidy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">snpL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">snpL</span> <span class="o">==</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">snpL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">minPos</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
                    <span class="n">minI</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">snpL</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> \
                   <span class="n">snpL</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">minPos</span><span class="p">:</span>
                    <span class="n">minPos</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
                    <span class="n">minI</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">minI</span><span class="p">,</span> <span class="n">snpL</span><span class="p">[</span><span class="n">minI</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">snpL</span><span class="p">[</span><span class="n">minI</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcf</span><span class="o">.</span><span class="n">get_nuc_base_from_line</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">snpIterL</span><span class="p">[</span><span class="n">minI</span><span class="p">]),</span>
                                                        <span class="n">ploidy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">snpL</span><span class="p">[</span><span class="n">minI</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__purge_cD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_cD</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__fill_cD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iL</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">snpL</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill *self.cF*.</span>

<span class="sd">        Fill *self.cF* with data from reference at chromosome</span>
<span class="sd">        *self.chrom* and position *self.pos*. Possible SNPs in</span>
<span class="sd">        *slef.vcfL* at this position are considered.</span>

<span class="sd">        :param [int] iL: List with vcf indices of the SNPs in *snpL*,</span>
<span class="sd">            must be sorted.</span>
<span class="sd">        :param [NucBase] snpL: List with :class:`NucBase</span>
<span class="sd">            &lt;libPoMo.vcf.NucBase&gt;` SNPs at this position. None, if</span>
<span class="sd">            there is no SNP.</span>
<span class="sd">        :raises: :class:`NotAValidRefBase</span>
<span class="sd">            &lt;libPoMo.seqbase.NotAValidRefBase&gt;`,</span>
<span class="sd">            :class:`SequenceDataError</span>
<span class="sd">            &lt;libPoMo.seqbase.SequenceDataError&gt;`</span>

<span class="sd">        :class:`NotAValidRefBae &lt;libPoMo.seqbase.NotAValidRefBase&gt;` is</span>
<span class="sd">        raised if the reference base is not valid (e.g. N).</span>

<span class="sd">        :class:`SequenceDataError &lt;libPoMo.seqbase.SequenceDataError&gt;`</span>
<span class="sd">        is raised if the chromosome names do not match.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">snpL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;Next SNP(s):&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">snpL</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">print_info</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">get_refBase</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Get reference base on *chrom* at *pos*.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">refSeq</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__purge_cD</span><span class="p">()</span>

        <span class="c"># If we check for synonymous bases, do not do anything if base</span>
        <span class="c"># is not 4-fold degenerate.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">onlySynonymous</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">refSeq</span><span class="o">.</span><span class="n">is_synonymous</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Rejection;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">refSeq</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">],</span>
                          <span class="s">&quot;at position&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="s">&quot;is not a synonymous base.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">NoSynBase</span><span class="p">()</span>

        <span class="n">refBase</span> <span class="o">=</span> <span class="n">get_refBase</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">dna</span><span class="p">[</span><span class="n">refBase</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">NotAValidRefBase</span><span class="p">()</span>
        <span class="c"># If there are no SNPS, fill *self.cD* with data from reference.</span>
        <span class="k">if</span> <span class="n">iL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">snpL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iL</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">snpL</span><span class="p">)):</span>
            <span class="c"># Else, only fill *self.cD* where the individual has no SNP.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">iL</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span>
            <span class="c"># Now traverse the SNPs.</span>
            <span class="k">for</span> <span class="n">sI</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iL</span><span class="p">)):</span>
                <span class="c"># Check if the reference bases match.</span>
                <span class="n">vcfRefBase</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span><span class="o">.</span><span class="n">get_ref_base</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">dna</span><span class="p">[</span><span class="n">vcfRefBase</span><span class="p">]</span> <span class="o">!=</span> <span class="n">r</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Error at NucBase:&quot;</span><span class="p">)</span>
                    <span class="n">snpL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span><span class="o">.</span><span class="n">print_info</span><span class="p">()</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;The reference base at position&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                          <span class="s">&quot;on chromosome&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                          <span class="s">&quot;is&quot;</span><span class="p">,</span> <span class="n">refBase</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">&quot;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;The reference base of the VCF file is&quot;</span><span class="p">,</span>
                          <span class="n">vcfRefBase</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">&quot;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s">&quot;Reference bases do not match.&quot;</span><span class="p">)</span>
                <span class="n">altBases</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span><span class="o">.</span><span class="n">get_alt_base_list</span><span class="p">()</span>
                <span class="n">spData</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span><span class="o">.</span><span class="n">get_speciesData</span><span class="p">()</span>
                <span class="n">vI</span> <span class="o">=</span> <span class="n">iL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span>
                <span class="c"># Loop over individuals.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">spData</span><span class="p">)):</span>
                <span class="c"># Loop over chromatides (e.g. diploid).</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">spData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="k">elif</span> <span class="n">spData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">bI</span> <span class="o">=</span> <span class="n">r</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">vI</span><span class="p">][</span><span class="n">i</span><span class="p">]][</span><span class="n">bI</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">bI</span> <span class="o">=</span> <span class="n">dna</span><span class="p">[</span><span class="n">altBases</span><span class="p">[</span><span class="n">spData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">vI</span><span class="p">][</span><span class="n">i</span><span class="p">]][</span><span class="n">bI</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s">&quot;SNP information is not correct.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_Ln</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return string with a line in counts format. Positional information</span>
<span class="sd">        is written 1-based.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stringL</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">:</span>
            <span class="n">stringL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">)))</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stringL</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_HLn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string containing the headerline in counts format.&quot;&quot;&quot;</span>
        <span class="n">strL</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;CHROM&quot;</span><span class="p">,</span> <span class="s">&quot;POS&quot;</span><span class="p">]</span>
        <span class="n">strL</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strL</span><span class="p">)</span>

<div class="viewcode-block" id="CFWriter.set_force"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.set_force">[docs]</a>    <span class="k">def</span> <span class="nf">set_force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets *self.__force* to *val*.</span>

<span class="sd">        :param Boolean val:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__force</span> <span class="o">=</span> <span class="n">val</span>
</div>
<div class="viewcode-block" id="CFWriter.set_seq"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.set_seq">[docs]</a>    <span class="k">def</span> <span class="nf">set_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="s">&quot;Set the reference sequence.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">sb</span><span class="o">.</span><span class="n">Seq</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s">&quot;`seq` is not a Seq object.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refSeq</span> <span class="o">=</span> <span class="n">seq</span>
</div>
<div class="viewcode-block" id="CFWriter.set_ploidy"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.set_ploidy">[docs]</a>    <span class="k">def</span> <span class="nf">set_ploidy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ploidy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the ploidy.</span>

<span class="sd">        In VCF files, usually the bases of all copies of the same</span>
<span class="sd">        chromosomes are given and separated by &#39;/&#39; or &#39;|&#39;.  If the</span>
<span class="sd">        species is not diploid, this ploidy has to be set manually</span>
<span class="sd">        with this function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">=</span> <span class="n">ploidy</span>
</div>
<div class="viewcode-block" id="CFWriter.set_offset"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.set_offset">[docs]</a>    <span class="k">def</span> <span class="nf">set_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the offset of the sequence.</span>

<span class="sd">        :param int offset: Value that can be set, if the reference</span>
<span class="sd">                           sequence does not start at the 1-based</span>
<span class="sd">                           position 1 but at the 1-based position</span>
<span class="sd">                           *offset*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Offset in CFWriter:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__write_Ln</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write a line in counts format to *self.outFN*.&quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_Ln</span><span class="p">(),</span> <span class="nb">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outFO</span><span class="p">)</span>

<div class="viewcode-block" id="CFWriter.write_HLn"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.write_HLn">[docs]</a>    <span class="k">def</span> <span class="nf">write_HLn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the counts format header line to *self.outFN*.&quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_HLn</span><span class="p">(),</span> <span class="nb">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outFO</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="CFWriter.write_Rn"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.write_Rn">[docs]</a>    <span class="k">def</span> <span class="nf">write_Rn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write lines in counts format to *self.outFN*.</span>

<span class="sd">        :param Region rg: :class:`Region &lt;libPoMo.seqbase.Region&gt;`</span>
<span class="sd">                          object that determines the region that is</span>
<span class="sd">                          covered.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_offset</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">snpsG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__snp</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="p">(</span><span class="n">nI</span><span class="p">,</span> <span class="n">nSNP</span><span class="p">)</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">snpsG</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="n">nI</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">nSNP</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">for</span> <span class="n">rPos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">rg</span><span class="o">.</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">snpL</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">iL</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">nI</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nSNP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nSNP</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">rPos</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">snpL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
                        <span class="n">snpL</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">iL</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">snpL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nSNP</span><span class="p">)</span>
                    <span class="n">iL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nI</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="p">(</span><span class="n">nI</span><span class="p">,</span> <span class="n">nSNP</span><span class="p">)</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">snpsG</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                        <span class="n">nI</span> <span class="o">=</span> <span class="bp">None</span>
                        <span class="n">nSNP</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">rg</span><span class="o">.</span><span class="n">chrom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">rPos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__fill_cD</span><span class="p">(</span><span class="n">iL</span><span class="p">,</span> <span class="n">snpL</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">sb</span><span class="o">.</span><span class="n">NotAValidRefBase</span><span class="p">:</span>
                <span class="c"># Do nothing if reference base is not valid.</span>
                <span class="k">pass</span>
            <span class="k">except</span> <span class="n">NoSynBase</span><span class="p">:</span>
                <span class="c"># Do nothing if base is not 4-fold degenerate.</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__write_Ln</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="CFWriter.close"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close fileobjects.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="p">:</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outFO</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

</div></div>
<div class="viewcode-block" id="write_cf_from_MFaStream"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.write_cf_from_MFaStream">[docs]</a><span class="k">def</span> <span class="nf">write_cf_from_MFaStream</span><span class="p">(</span><span class="n">refMFaStr</span><span class="p">,</span> <span class="n">cfWr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write counts file using the given MFaStream and CFWriter.</span>

<span class="sd">    Write the counts format file using the first sequences of all</span>
<span class="sd">    alignments in the MFaStream.  The sequences are automatically</span>
<span class="sd">    reversed and complemented if this is needed (indicated in the</span>
<span class="sd">    header line).  This is very useful if you e.g. want to compare the</span>
<span class="sd">    VCF files to a CCDC alignment.</span>

<span class="sd">    :param FMaStream refMFaStr: The reference :class:`MFaStream</span>
<span class="sd">      &lt;libPoMo.fasta.MFaStream&gt;`.</span>
<span class="sd">    :param CFWriter cfWf: The :class:`CFWriter` object that contains</span>
<span class="sd">      the VCF files.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">refMFaStr</span><span class="o">.</span><span class="n">orient</span><span class="p">(</span><span class="n">firstOnly</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">rg</span> <span class="o">=</span> <span class="n">refMFaStr</span><span class="o">.</span><span class="n">seqL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_region</span><span class="p">()</span>
        <span class="n">cfWr</span><span class="o">.</span><span class="n">set_seq</span><span class="p">(</span><span class="n">refMFaStr</span><span class="o">.</span><span class="n">seqL</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cfWr</span><span class="o">.</span><span class="n">write_Rn</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">refMFaStr</span><span class="o">.</span><span class="n">read_next_align</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">break</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">PoMo 1.0.2 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Dominik Schrempf.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.1.
    </div>
  </body>
</html>